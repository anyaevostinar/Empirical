Emphatic is an internal coding for Empirical that will try to support as many text encodings as reasonable, simplifying the conversion between them while being easy to write to in code (via the emp::Text object.)

Supported text formats:
 TXT (plain text - working)
 HTML (simple tags working)
 LATEX
 MARKDOWN
 RTF
 XML
 MarkBack (custom markup language; simple tags working)

Internal encoding (Emphatic)
 The Emphatic encoding maintains a string of characters, each associated with any number of styles.  The standard styles are:
  bold
  code
  comment (text that should not be shown in final output)
  italic
  strike (for strikethrough)
  subscript
  superscript
  underline

 Some styles are only associated with individual special characters (usually matched with a space).  This are:
  no_break - non-breaking space
  bullet
  ordered
  indent
  blockquote - Marks this line as being part of a blockquote.

 Additional styles are followed by a colon and details must be provided.
  header - followed by header level (e.g.: header:1)
  link - text should redirect to provided URL (e.g.: link:https://google.com)
  image - followed by location of image.
  


MarkBack notes:
 *  New format is .mback, which uses just a backquote (`) as a special character.  It
 *  is otherwise inspired from markdown, but makes special characters easy to use.
 *  The only other reserved special character is backslash (`\`), discussed below.
 *  
 *  The following tags toggle a formatting style.
 * 
 *  `*Bold!`*
 *  ``Code``
 *  `/Italic`/
 *  `_Underlined!`_
 *  `^Superscript`^
 *  `.Subscript`.
 *  `~Strikethrough`~
 * 
 *  The following tags grab the rest of the line they are on.  These should generally
 *  be the first non-whitespace on a line, but not a newline will be assumed before them.
 * 
 *  `# Heading level 1
 *  `## Heading level 2
 *  `### etc. deeper headings.
 *  `" Blockquote
 *  `- Bulleted list entry
 *  `+ Numbered list entry
 *  `| Continues the previous line for other tags in this group.
 *  `% Comment that will be removed.
 * 
 *  `[Include a link name here](http://and.its.url.here)
 *  `<http://just.a.url.here>
 *  `![Link/to/image/here.jpg](http://optional.URL.link)
 * 
 *  Now for the crazy.  We can embed code as needed.
 * 
 *  `{variable = value || other_code}
 *  `$var_value_printed_here$
 * 
 *  Anything with three backticks (```) before and after will be treated as code blocks.
 *  Add a `= at the beginning of a line if you don't want any special formatting.
 *   
 *  A single or double backtick indicates that everything in between is going to be inline
 *  code.  A single backtick must be followed by an alphanumeric character or whitespace,
 *  but a double backtick can be followed by anything.
 * 
 *  `This would be rendered as CODE`
 *  ``{This would also be code, with the braces appearing}``
 * 
 *  Escape characters do work.
 *  \\ is a regular backslash ('\')
 *  \` is a backtick in the actual string ('`')
 *  \  (backlash space) is a non-breaking space.
 *  \123 (or any other number) converts to the associated unicode character.
 *  \. is nothing. Use to separate other text (e.g., unicode followed by number)
 *  \n is a newline
 *  \t is a tab


Some saved notes:
    // Tag layout differs substantially from one language to the next.  For example, to make
    // text have the style "bold", it may look like:
    //   HTML:      One word is <b>bold</b>.
    //   MarkDown:  One word is *bold*.
    //   LaTeX:     One word is \textbf{bold}.
    //   MarkBack:  One word is `*bold`*
    //
    // Some styles need to have arguments associated with them.  For example, a heading needs
    // to have a level.  A level 3 heading, for example, would be stored as style "heading:3".
    //   HTML:      <h3>A level 3 heading</h3>
    //   MarkDown:  ### A level 3 heading
    //   LaTeX:     \subsubsection{A level 3 heading}
    //   MarkBack:  `### A level 3 heading
    //
    // The patterns associated with these can either be broken up into multiple tags (for example,
    // in LaTeX it's easier to match a specific "\subsubsection{" open tag with "header:3" style),
    // while HTML can use the pattern "H$d" mapping to "header:$0".  In Markdown we would use
    // "$r{#}" mapping to "header:$0"
    //
    // Finally, more complex tags are possible.  For example, if a tag is supposed to map a
    // series of words to a linked URL:
    //   HTML:      This is <a href="http://www.exmaple.com/">linked</a> text.
    //   MarkDown:  This is [linked](http://www.exmaple.com/) text.
    //   LaTeX:     This is \href{http://www.exmaple.com/}{linked} text.
    //   MarkBack:  This is `[linked](http://www.exmaple.com/) text.
    //
    // For these patterns, HTML open would look like: <a href="%u">
    // And it would be set to the style: "link:$0".

Original comments on tag pattern:
      // What pattern will identify this tag?  Any characters EXCEPT $ will be taken literally.
      // $$ will be a single $.  A $ followed by a letter will have a specific meaning.
      //   $d = A single digit (0 to 9)
      //   $f = Any filename (includes a-z, A-Z, 0-9, '_', '/', '.', and '-')
      //   $i = Any identifier sequence (includes a-z, A-Z, 0-9 and '_')
      //   $n = Any whole number sequence (a series of digits)
      //   $r{pattern} = A repeated pattern
      //   @CAO FUTURE ADDITION: $t = Any normal text
      //   $u = Any URL

For style replacements:
      // A more complex style uses a replacement pattern to generate its description.  It can use $0
      // through $9 for the $letter material in the pattern. (e.g., a font should track the
      // name of the font.)

And for converting a pattern to a normal regex:
```cpp
      std::string AsRegEx() {
        std::string out;
        for (size_t i = 0; i < pattern.size(); ++i) {
          if (pattern[i] == '$') {
            ++i;
            emp_assert(i < pattern.size());
            switch (pattern[i]) {
              case '$': out += "$"; break;
              case 'd': out += "[0-9]"; break;
              case 'f': out += "[a-zA-Z0-9_/.-]+"; break;
              case 'i': out += "[a-zA-Z0-9_]+"; break;
              case 'n': out += "[0-9]+"; break;
              case 'r':
                {
                  size_t start = i;
                  i = emp::find_paren_match(pattern, i, '{', '}', false);
                  out += "\"" + pattern.substr(start+1, i-start-1) + "\"+";
                }
                break;
              case 't': out += "[]"; break;
              case 'u': out += "[a-zA-Z0-9_/.+:-]"; break;
            }
          }
          else if (pattern[0] == '[') out += "[\\[]";
          else if (pattern[0] == ']') out += "[\\]]";
          else if (pattern[0] == '*') out += "[*]";
          else if (pattern[0] == '.') out += "[.]";
          else if (pattern[0] == '+') out += "[+]";
          else if (pattern[0] == '?') out += "[?]";
          else if (pattern[0] == '|') out += "[|]";
          else if (pattern[0] == '(') out += "[()]";
          else if (pattern[0] == ')') out += "[)]";
          else out += pattern[i];
        }
        return out;
      }
```